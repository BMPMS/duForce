import {
  require_foreach,
  require_is_graph,
  require_iterables
} from "./chunk-3F5NPONY.js";
import {
  require_iterator
} from "./chunk-KA5TYL5E.js";
import {
  __commonJS
} from "./chunk-5WWUZCGV.js";

// node_modules/mnemonist/queue.js
var require_queue = __commonJS({
  "node_modules/mnemonist/queue.js"(exports, module) {
    var Iterator = require_iterator();
    var forEach = require_foreach();
    function Queue() {
      this.clear();
    }
    Queue.prototype.clear = function() {
      this.items = [];
      this.offset = 0;
      this.size = 0;
    };
    Queue.prototype.enqueue = function(item) {
      this.items.push(item);
      return ++this.size;
    };
    Queue.prototype.dequeue = function() {
      if (!this.size)
        return;
      var item = this.items[this.offset];
      if (++this.offset * 2 >= this.items.length) {
        this.items = this.items.slice(this.offset);
        this.offset = 0;
      }
      this.size--;
      return item;
    };
    Queue.prototype.peek = function() {
      if (!this.size)
        return;
      return this.items[this.offset];
    };
    Queue.prototype.forEach = function(callback, scope) {
      scope = arguments.length > 1 ? scope : this;
      for (var i = this.offset, j = 0, l = this.items.length; i < l; i++, j++)
        callback.call(scope, this.items[i], j, this);
    };
    Queue.prototype.toArray = function() {
      return this.items.slice(this.offset);
    };
    Queue.prototype.values = function() {
      var items = this.items, i = this.offset;
      return new Iterator(function() {
        if (i >= items.length)
          return {
            done: true
          };
        var value = items[i];
        i++;
        return {
          value,
          done: false
        };
      });
    };
    Queue.prototype.entries = function() {
      var items = this.items, i = this.offset, j = 0;
      return new Iterator(function() {
        if (i >= items.length)
          return {
            done: true
          };
        var value = items[i];
        i++;
        return {
          value: [j++, value],
          done: false
        };
      });
    };
    if (typeof Symbol !== "undefined")
      Queue.prototype[Symbol.iterator] = Queue.prototype.values;
    Queue.prototype.toString = function() {
      return this.toArray().join(",");
    };
    Queue.prototype.toJSON = function() {
      return this.toArray();
    };
    Queue.prototype.inspect = function() {
      var array = this.toArray();
      Object.defineProperty(array, "constructor", {
        value: Queue,
        enumerable: false
      });
      return array;
    };
    if (typeof Symbol !== "undefined")
      Queue.prototype[Symbol.for("nodejs.util.inspect.custom")] = Queue.prototype.inspect;
    Queue.from = function(iterable) {
      var queue = new Queue();
      forEach(iterable, function(value) {
        queue.enqueue(value);
      });
      return queue;
    };
    Queue.of = function() {
      return Queue.from(arguments);
    };
    module.exports = Queue;
  }
});

// node_modules/@yomguithereal/helpers/extend.js
var require_extend = __commonJS({
  "node_modules/@yomguithereal/helpers/extend.js"(exports, module) {
    module.exports = function extend(array, values) {
      var l2 = values.length;
      if (l2 === 0)
        return;
      var l1 = array.length;
      array.length += l2;
      for (var i = 0; i < l2; i++)
        array[l1 + i] = values[i];
    };
  }
});

// node_modules/graphology-shortest-path/unweighted.js
var require_unweighted = __commonJS({
  "node_modules/graphology-shortest-path/unweighted.js"(exports) {
    var isGraph = require_is_graph();
    var Queue = require_queue();
    var extend = require_extend();
    function bidirectional(graph, source, target) {
      if (!isGraph(graph))
        throw new Error("graphology-shortest-path: invalid graphology instance.");
      if (arguments.length < 3)
        throw new Error(
          "graphology-shortest-path: invalid number of arguments. Expecting at least 3."
        );
      if (!graph.hasNode(source))
        throw new Error(
          'graphology-shortest-path: the "' + source + '" source node does not exist in the given graph.'
        );
      if (!graph.hasNode(target))
        throw new Error(
          'graphology-shortest-path: the "' + target + '" target node does not exist in the given graph.'
        );
      source = "" + source;
      target = "" + target;
      if (source === target) {
        return [source];
      }
      var getPredecessors = graph.inboundNeighbors.bind(graph), getSuccessors = graph.outboundNeighbors.bind(graph);
      var predecessor = {}, successor = {};
      predecessor[source] = null;
      successor[target] = null;
      var forwardFringe = [source], reverseFringe = [target], currentFringe, node, neighbors, neighbor, i, j, l, m;
      var found = false;
      outer:
        while (forwardFringe.length && reverseFringe.length) {
          if (forwardFringe.length <= reverseFringe.length) {
            currentFringe = forwardFringe;
            forwardFringe = [];
            for (i = 0, l = currentFringe.length; i < l; i++) {
              node = currentFringe[i];
              neighbors = getSuccessors(node);
              for (j = 0, m = neighbors.length; j < m; j++) {
                neighbor = neighbors[j];
                if (!(neighbor in predecessor)) {
                  forwardFringe.push(neighbor);
                  predecessor[neighbor] = node;
                }
                if (neighbor in successor) {
                  found = true;
                  break outer;
                }
              }
            }
          } else {
            currentFringe = reverseFringe;
            reverseFringe = [];
            for (i = 0, l = currentFringe.length; i < l; i++) {
              node = currentFringe[i];
              neighbors = getPredecessors(node);
              for (j = 0, m = neighbors.length; j < m; j++) {
                neighbor = neighbors[j];
                if (!(neighbor in successor)) {
                  reverseFringe.push(neighbor);
                  successor[neighbor] = node;
                }
                if (neighbor in predecessor) {
                  found = true;
                  break outer;
                }
              }
            }
          }
        }
      if (!found)
        return null;
      var path = [];
      while (neighbor) {
        path.unshift(neighbor);
        neighbor = predecessor[neighbor];
      }
      neighbor = successor[path[path.length - 1]];
      while (neighbor) {
        path.push(neighbor);
        neighbor = successor[neighbor];
      }
      return path.length ? path : null;
    }
    function singleSource(graph, source) {
      if (!isGraph(graph))
        throw new Error("graphology-shortest-path: invalid graphology instance.");
      if (arguments.length < 2)
        throw new Error(
          "graphology-shortest-path: invalid number of arguments. Expecting at least 2."
        );
      if (!graph.hasNode(source))
        throw new Error(
          'graphology-shortest-path: the "' + source + '" source node does not exist in the given graph.'
        );
      source = "" + source;
      var nextLevel = {}, paths = {}, currentLevel, neighbors, v, w, i, l;
      nextLevel[source] = true;
      paths[source] = [source];
      while (Object.keys(nextLevel).length) {
        currentLevel = nextLevel;
        nextLevel = {};
        for (v in currentLevel) {
          neighbors = graph.outboundNeighbors(v);
          for (i = 0, l = neighbors.length; i < l; i++) {
            w = neighbors[i];
            if (!paths[w]) {
              paths[w] = paths[v].concat(w);
              nextLevel[w] = true;
            }
          }
        }
      }
      return paths;
    }
    function asbtractSingleSourceLength(method, graph, source) {
      if (!isGraph(graph))
        throw new Error("graphology-shortest-path: invalid graphology instance.");
      if (!graph.hasNode(source))
        throw new Error(
          'graphology-shortest-path: the "' + source + '" source node does not exist in the given graph.'
        );
      source = "" + source;
      var seen = /* @__PURE__ */ new Set();
      var lengths = {}, level = 0;
      lengths[source] = 0;
      var currentLevel = [source];
      var i, l, node;
      while (currentLevel.length !== 0) {
        var nextLevel = [];
        for (i = 0, l = currentLevel.length; i < l; i++) {
          node = currentLevel[i];
          if (seen.has(node))
            continue;
          seen.add(node);
          extend(nextLevel, graph[method](node));
          lengths[node] = level;
        }
        level++;
        currentLevel = nextLevel;
      }
      return lengths;
    }
    var singleSourceLength = asbtractSingleSourceLength.bind(
      null,
      "outboundNeighbors"
    );
    var undirectedSingleSourceLength = asbtractSingleSourceLength.bind(
      null,
      "neighbors"
    );
    function brandes(graph, source) {
      source = "" + source;
      var S = [], P = {}, sigma = {};
      var nodes = graph.nodes(), Dv, sigmav, neighbors, v, w, i, j, l, m;
      for (i = 0, l = nodes.length; i < l; i++) {
        v = nodes[i];
        P[v] = [];
        sigma[v] = 0;
      }
      var D = {};
      sigma[source] = 1;
      D[source] = 0;
      var queue = Queue.of(source);
      while (queue.size) {
        v = queue.dequeue();
        S.push(v);
        Dv = D[v];
        sigmav = sigma[v];
        neighbors = graph.outboundNeighbors(v);
        for (j = 0, m = neighbors.length; j < m; j++) {
          w = neighbors[j];
          if (!(w in D)) {
            queue.enqueue(w);
            D[w] = Dv + 1;
          }
          if (D[w] === Dv + 1) {
            sigma[w] += sigmav;
            P[w].push(v);
          }
        }
      }
      return [S, P, sigma];
    }
    exports.bidirectional = bidirectional;
    exports.singleSource = singleSource;
    exports.singleSourceLength = singleSourceLength;
    exports.undirectedSingleSourceLength = undirectedSingleSourceLength;
    exports.brandes = brandes;
  }
});

// node_modules/graphology-shortest-path/utils.js
var require_utils = __commonJS({
  "node_modules/graphology-shortest-path/utils.js"(exports) {
    var returnTrue = function() {
      return true;
    };
    exports.edgePathFromNodePath = function(graph, nodePath) {
      var l = nodePath.length;
      var i, source, target, edge;
      if (l < 2) {
        source = nodePath[0];
        edge = graph.multi ? graph.findEdge(source, source, returnTrue) : graph.edge(source, source);
        if (edge)
          return [edge];
        return [];
      }
      l--;
      var edgePath = new Array(l);
      for (i = 0; i < l; i++) {
        source = nodePath[i];
        target = nodePath[i + 1];
        edge = graph.multi ? graph.findOutboundEdge(source, target, returnTrue) : graph.edge(source, target);
        if (edge === void 0)
          throw new Error(
            "graphology-shortest-path: given path is impossible in given graph."
          );
        edgePath[i] = edge;
      }
      return edgePath;
    };
  }
});

// node_modules/graphology-utils/getters.js
var require_getters = __commonJS({
  "node_modules/graphology-utils/getters.js"(exports) {
    function coerceWeight(value) {
      if (typeof value !== "number" || isNaN(value))
        return 1;
      return value;
    }
    function createNodeValueGetter(nameOrFunction, defaultValue) {
      var getter = {};
      var coerceToDefault = function(v) {
        if (typeof v === "undefined")
          return defaultValue;
        return v;
      };
      if (typeof defaultValue === "function")
        coerceToDefault = defaultValue;
      var get = function(attributes) {
        return coerceToDefault(attributes[nameOrFunction]);
      };
      var returnDefault = function() {
        return coerceToDefault(void 0);
      };
      if (typeof nameOrFunction === "string") {
        getter.fromAttributes = get;
        getter.fromGraph = function(graph, node) {
          return get(graph.getNodeAttributes(node));
        };
        getter.fromEntry = function(node, attributes) {
          return get(attributes);
        };
      } else if (typeof nameOrFunction === "function") {
        getter.fromAttributes = function() {
          throw new Error(
            "graphology-utils/getters/createNodeValueGetter: irrelevant usage."
          );
        };
        getter.fromGraph = function(graph, node) {
          return coerceToDefault(
            nameOrFunction(node, graph.getNodeAttributes(node))
          );
        };
        getter.fromEntry = function(node, attributes) {
          return coerceToDefault(nameOrFunction(node, attributes));
        };
      } else {
        getter.fromAttributes = returnDefault;
        getter.fromGraph = returnDefault;
        getter.fromEntry = returnDefault;
      }
      return getter;
    }
    function createEdgeValueGetter(nameOrFunction, defaultValue) {
      var getter = {};
      var coerceToDefault = function(v) {
        if (typeof v === "undefined")
          return defaultValue;
        return v;
      };
      if (typeof defaultValue === "function")
        coerceToDefault = defaultValue;
      var get = function(attributes) {
        return coerceToDefault(attributes[nameOrFunction]);
      };
      var returnDefault = function() {
        return coerceToDefault(void 0);
      };
      if (typeof nameOrFunction === "string") {
        getter.fromAttributes = get;
        getter.fromGraph = function(graph, edge) {
          return get(graph.getEdgeAttributes(edge));
        };
        getter.fromEntry = function(edge, attributes) {
          return get(attributes);
        };
        getter.fromPartialEntry = getter.fromEntry;
        getter.fromMinimalEntry = getter.fromEntry;
      } else if (typeof nameOrFunction === "function") {
        getter.fromAttributes = function() {
          throw new Error(
            "graphology-utils/getters/createEdgeValueGetter: irrelevant usage."
          );
        };
        getter.fromGraph = function(graph, edge) {
          var extremities = graph.extremities(edge);
          return coerceToDefault(
            nameOrFunction(
              edge,
              graph.getEdgeAttributes(edge),
              extremities[0],
              extremities[1],
              graph.getNodeAttributes(extremities[0]),
              graph.getNodeAttributes(extremities[1]),
              graph.isUndirected(edge)
            )
          );
        };
        getter.fromEntry = function(e, a, s, t, sa, ta, u) {
          return coerceToDefault(nameOrFunction(e, a, s, t, sa, ta, u));
        };
        getter.fromPartialEntry = function(e, a, s, t) {
          return coerceToDefault(nameOrFunction(e, a, s, t));
        };
        getter.fromMinimalEntry = function(e, a) {
          return coerceToDefault(nameOrFunction(e, a));
        };
      } else {
        getter.fromAttributes = returnDefault;
        getter.fromGraph = returnDefault;
        getter.fromEntry = returnDefault;
        getter.fromMinimalEntry = returnDefault;
      }
      return getter;
    }
    exports.createNodeValueGetter = createNodeValueGetter;
    exports.createEdgeValueGetter = createEdgeValueGetter;
    exports.createEdgeWeightGetter = function(name) {
      return createEdgeValueGetter(name, coerceWeight);
    };
  }
});

// node_modules/mnemonist/utils/comparators.js
var require_comparators = __commonJS({
  "node_modules/mnemonist/utils/comparators.js"(exports) {
    var DEFAULT_COMPARATOR = function(a, b) {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    };
    var DEFAULT_REVERSE_COMPARATOR = function(a, b) {
      if (a < b)
        return 1;
      if (a > b)
        return -1;
      return 0;
    };
    function reverseComparator(comparator) {
      return function(a, b) {
        return comparator(b, a);
      };
    }
    function createTupleComparator(size) {
      if (size === 2) {
        return function(a, b) {
          if (a[0] < b[0])
            return -1;
          if (a[0] > b[0])
            return 1;
          if (a[1] < b[1])
            return -1;
          if (a[1] > b[1])
            return 1;
          return 0;
        };
      }
      return function(a, b) {
        var i = 0;
        while (i < size) {
          if (a[i] < b[i])
            return -1;
          if (a[i] > b[i])
            return 1;
          i++;
        }
        return 0;
      };
    }
    exports.DEFAULT_COMPARATOR = DEFAULT_COMPARATOR;
    exports.DEFAULT_REVERSE_COMPARATOR = DEFAULT_REVERSE_COMPARATOR;
    exports.reverseComparator = reverseComparator;
    exports.createTupleComparator = createTupleComparator;
  }
});

// node_modules/mnemonist/heap.js
var require_heap = __commonJS({
  "node_modules/mnemonist/heap.js"(exports, module) {
    var forEach = require_foreach();
    var comparators = require_comparators();
    var iterables = require_iterables();
    var DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR;
    var reverseComparator = comparators.reverseComparator;
    function siftDown(compare, heap, startIndex, i) {
      var item = heap[i], parentIndex, parent;
      while (i > startIndex) {
        parentIndex = i - 1 >> 1;
        parent = heap[parentIndex];
        if (compare(item, parent) < 0) {
          heap[i] = parent;
          i = parentIndex;
          continue;
        }
        break;
      }
      heap[i] = item;
    }
    function siftUp(compare, heap, i) {
      var endIndex = heap.length, startIndex = i, item = heap[i], childIndex = 2 * i + 1, rightIndex;
      while (childIndex < endIndex) {
        rightIndex = childIndex + 1;
        if (rightIndex < endIndex && compare(heap[childIndex], heap[rightIndex]) >= 0) {
          childIndex = rightIndex;
        }
        heap[i] = heap[childIndex];
        i = childIndex;
        childIndex = 2 * i + 1;
      }
      heap[i] = item;
      siftDown(compare, heap, startIndex, i);
    }
    function push(compare, heap, item) {
      heap.push(item);
      siftDown(compare, heap, 0, heap.length - 1);
    }
    function pop(compare, heap) {
      var lastItem = heap.pop();
      if (heap.length !== 0) {
        var item = heap[0];
        heap[0] = lastItem;
        siftUp(compare, heap, 0);
        return item;
      }
      return lastItem;
    }
    function replace(compare, heap, item) {
      if (heap.length === 0)
        throw new Error("mnemonist/heap.replace: cannot pop an empty heap.");
      var popped = heap[0];
      heap[0] = item;
      siftUp(compare, heap, 0);
      return popped;
    }
    function pushpop(compare, heap, item) {
      var tmp;
      if (heap.length !== 0 && compare(heap[0], item) < 0) {
        tmp = heap[0];
        heap[0] = item;
        item = tmp;
        siftUp(compare, heap, 0);
      }
      return item;
    }
    function heapify(compare, array) {
      var n = array.length, l = n >> 1, i = l;
      while (--i >= 0)
        siftUp(compare, array, i);
    }
    function consume(compare, heap) {
      var l = heap.length, i = 0;
      var array = new Array(l);
      while (i < l)
        array[i++] = pop(compare, heap);
      return array;
    }
    function nsmallest(compare, n, iterable) {
      if (arguments.length === 2) {
        iterable = n;
        n = compare;
        compare = DEFAULT_COMPARATOR;
      }
      var reverseCompare = reverseComparator(compare);
      var i, l, v;
      var min = Infinity;
      var result;
      if (n === 1) {
        if (iterables.isArrayLike(iterable)) {
          for (i = 0, l = iterable.length; i < l; i++) {
            v = iterable[i];
            if (min === Infinity || compare(v, min) < 0)
              min = v;
          }
          result = new iterable.constructor(1);
          result[0] = min;
          return result;
        }
        forEach(iterable, function(value) {
          if (min === Infinity || compare(value, min) < 0)
            min = value;
        });
        return [min];
      }
      if (iterables.isArrayLike(iterable)) {
        if (n >= iterable.length)
          return iterable.slice().sort(compare);
        result = iterable.slice(0, n);
        heapify(reverseCompare, result);
        for (i = n, l = iterable.length; i < l; i++)
          if (reverseCompare(iterable[i], result[0]) > 0)
            replace(reverseCompare, result, iterable[i]);
        return result.sort(compare);
      }
      var size = iterables.guessLength(iterable);
      if (size !== null && size < n)
        n = size;
      result = new Array(n);
      i = 0;
      forEach(iterable, function(value) {
        if (i < n) {
          result[i] = value;
        } else {
          if (i === n)
            heapify(reverseCompare, result);
          if (reverseCompare(value, result[0]) > 0)
            replace(reverseCompare, result, value);
        }
        i++;
      });
      if (result.length > i)
        result.length = i;
      return result.sort(compare);
    }
    function nlargest(compare, n, iterable) {
      if (arguments.length === 2) {
        iterable = n;
        n = compare;
        compare = DEFAULT_COMPARATOR;
      }
      var reverseCompare = reverseComparator(compare);
      var i, l, v;
      var max = -Infinity;
      var result;
      if (n === 1) {
        if (iterables.isArrayLike(iterable)) {
          for (i = 0, l = iterable.length; i < l; i++) {
            v = iterable[i];
            if (max === -Infinity || compare(v, max) > 0)
              max = v;
          }
          result = new iterable.constructor(1);
          result[0] = max;
          return result;
        }
        forEach(iterable, function(value) {
          if (max === -Infinity || compare(value, max) > 0)
            max = value;
        });
        return [max];
      }
      if (iterables.isArrayLike(iterable)) {
        if (n >= iterable.length)
          return iterable.slice().sort(reverseCompare);
        result = iterable.slice(0, n);
        heapify(compare, result);
        for (i = n, l = iterable.length; i < l; i++)
          if (compare(iterable[i], result[0]) > 0)
            replace(compare, result, iterable[i]);
        return result.sort(reverseCompare);
      }
      var size = iterables.guessLength(iterable);
      if (size !== null && size < n)
        n = size;
      result = new Array(n);
      i = 0;
      forEach(iterable, function(value) {
        if (i < n) {
          result[i] = value;
        } else {
          if (i === n)
            heapify(compare, result);
          if (compare(value, result[0]) > 0)
            replace(compare, result, value);
        }
        i++;
      });
      if (result.length > i)
        result.length = i;
      return result.sort(reverseCompare);
    }
    function Heap(comparator) {
      this.clear();
      this.comparator = comparator || DEFAULT_COMPARATOR;
      if (typeof this.comparator !== "function")
        throw new Error("mnemonist/Heap.constructor: given comparator should be a function.");
    }
    Heap.prototype.clear = function() {
      this.items = [];
      this.size = 0;
    };
    Heap.prototype.push = function(item) {
      push(this.comparator, this.items, item);
      return ++this.size;
    };
    Heap.prototype.peek = function() {
      return this.items[0];
    };
    Heap.prototype.pop = function() {
      if (this.size !== 0)
        this.size--;
      return pop(this.comparator, this.items);
    };
    Heap.prototype.replace = function(item) {
      return replace(this.comparator, this.items, item);
    };
    Heap.prototype.pushpop = function(item) {
      return pushpop(this.comparator, this.items, item);
    };
    Heap.prototype.consume = function() {
      this.size = 0;
      return consume(this.comparator, this.items);
    };
    Heap.prototype.toArray = function() {
      return consume(this.comparator, this.items.slice());
    };
    Heap.prototype.inspect = function() {
      var proxy = this.toArray();
      Object.defineProperty(proxy, "constructor", {
        value: Heap,
        enumerable: false
      });
      return proxy;
    };
    if (typeof Symbol !== "undefined")
      Heap.prototype[Symbol.for("nodejs.util.inspect.custom")] = Heap.prototype.inspect;
    function MaxHeap(comparator) {
      this.clear();
      this.comparator = comparator || DEFAULT_COMPARATOR;
      if (typeof this.comparator !== "function")
        throw new Error("mnemonist/MaxHeap.constructor: given comparator should be a function.");
      this.comparator = reverseComparator(this.comparator);
    }
    MaxHeap.prototype = Heap.prototype;
    Heap.from = function(iterable, comparator) {
      var heap = new Heap(comparator);
      var items;
      if (iterables.isArrayLike(iterable))
        items = iterable.slice();
      else
        items = iterables.toArray(iterable);
      heapify(heap.comparator, items);
      heap.items = items;
      heap.size = items.length;
      return heap;
    };
    MaxHeap.from = function(iterable, comparator) {
      var heap = new MaxHeap(comparator);
      var items;
      if (iterables.isArrayLike(iterable))
        items = iterable.slice();
      else
        items = iterables.toArray(iterable);
      heapify(heap.comparator, items);
      heap.items = items;
      heap.size = items.length;
      return heap;
    };
    Heap.siftUp = siftUp;
    Heap.siftDown = siftDown;
    Heap.push = push;
    Heap.pop = pop;
    Heap.replace = replace;
    Heap.pushpop = pushpop;
    Heap.heapify = heapify;
    Heap.consume = consume;
    Heap.nsmallest = nsmallest;
    Heap.nlargest = nlargest;
    Heap.MinHeap = Heap;
    Heap.MaxHeap = MaxHeap;
    module.exports = Heap;
  }
});

// node_modules/graphology-shortest-path/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/graphology-shortest-path/dijkstra.js"(exports) {
    var isGraph = require_is_graph();
    var createEdgeWeightGetter = require_getters().createEdgeWeightGetter;
    var Heap = require_heap();
    var DEFAULT_WEIGHT_ATTRIBUTE = "weight";
    function DIJKSTRA_HEAP_COMPARATOR(a, b) {
      if (a[0] > b[0])
        return 1;
      if (a[0] < b[0])
        return -1;
      if (a[1] > b[1])
        return 1;
      if (a[1] < b[1])
        return -1;
      if (a[2] > b[2])
        return 1;
      if (a[2] < b[2])
        return -1;
      return 0;
    }
    function BRANDES_DIJKSTRA_HEAP_COMPARATOR(a, b) {
      if (a[0] > b[0])
        return 1;
      if (a[0] < b[0])
        return -1;
      if (a[1] > b[1])
        return 1;
      if (a[1] < b[1])
        return -1;
      if (a[2] > b[2])
        return 1;
      if (a[2] < b[2])
        return -1;
      if (a[3] > b[3])
        return 1;
      if (a[3] < b[3])
        return -1;
      return 0;
    }
    function abstractBidirectionalDijkstra(graph, source, target, getEdgeWeight) {
      source = "" + source;
      target = "" + target;
      if (!isGraph(graph))
        throw new Error(
          "graphology-shortest-path/dijkstra: invalid graphology instance."
        );
      if (source && !graph.hasNode(source))
        throw new Error(
          'graphology-shortest-path/dijkstra: the "' + source + '" source node does not exist in the given graph.'
        );
      if (target && !graph.hasNode(target))
        throw new Error(
          'graphology-shortest-path/dijkstra: the "' + target + '" target node does not exist in the given graph.'
        );
      getEdgeWeight = createEdgeWeightGetter(
        getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE
      ).fromMinimalEntry;
      if (source === target)
        return [0, [source]];
      var distances = [{}, {}], paths = [{}, {}], fringe = [
        new Heap(DIJKSTRA_HEAP_COMPARATOR),
        new Heap(DIJKSTRA_HEAP_COMPARATOR)
      ], seen = [{}, {}];
      paths[0][source] = [source];
      paths[1][target] = [target];
      seen[0][source] = 0;
      seen[1][target] = 0;
      var finalPath = [], finalDistance = Infinity;
      var count = 0, dir = 1, item, edges, cost, d, v, u, e, i, l;
      fringe[0].push([0, count++, source]);
      fringe[1].push([0, count++, target]);
      while (fringe[0].size && fringe[1].size) {
        dir = 1 - dir;
        item = fringe[dir].pop();
        d = item[0];
        v = item[2];
        if (v in distances[dir])
          continue;
        distances[dir][v] = d;
        if (v in distances[1 - dir])
          return [finalDistance, finalPath];
        edges = dir === 1 ? graph.inboundEdges(v) : graph.outboundEdges(v);
        for (i = 0, l = edges.length; i < l; i++) {
          e = edges[i];
          u = graph.opposite(v, e);
          cost = distances[dir][v] + getEdgeWeight(e, graph.getEdgeAttributes(e));
          if (u in distances[dir] && cost < distances[dir][u]) {
            throw Error(
              "graphology-shortest-path/dijkstra: contradictory paths found. Do some of your edges have a negative weight?"
            );
          } else if (!(u in seen[dir]) || cost < seen[dir][u]) {
            seen[dir][u] = cost;
            fringe[dir].push([cost, count++, u]);
            paths[dir][u] = paths[dir][v].concat(u);
            if (u in seen[0] && u in seen[1]) {
              d = seen[0][u] + seen[1][u];
              if (finalPath.length === 0 || finalDistance > d) {
                finalDistance = d;
                finalPath = paths[0][u].concat(paths[1][u].slice(0, -1).reverse());
              }
            }
          }
        }
      }
      return [Infinity, null];
    }
    function abstractDijkstraMultisource(graph, sources, getEdgeWeight, cutoff, target, paths) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-shortest-path/dijkstra: invalid graphology instance."
        );
      if (target && !graph.hasNode(target))
        throw new Error(
          'graphology-shortest-path/dijkstra: the "' + target + '" target node does not exist in the given graph.'
        );
      getEdgeWeight = createEdgeWeightGetter(
        getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE
      ).fromMinimalEntry;
      var distances = {}, seen = {}, fringe = new Heap(DIJKSTRA_HEAP_COMPARATOR);
      var count = 0, edges, item, cost, v, u, e, d, i, j, l, m;
      for (i = 0, l = sources.length; i < l; i++) {
        v = sources[i];
        seen[v] = 0;
        fringe.push([0, count++, v]);
        if (paths)
          paths[v] = [v];
      }
      while (fringe.size) {
        item = fringe.pop();
        d = item[0];
        v = item[2];
        if (v in distances)
          continue;
        distances[v] = d;
        if (v === target)
          break;
        edges = graph.outboundEdges(v);
        for (j = 0, m = edges.length; j < m; j++) {
          e = edges[j];
          u = graph.opposite(v, e);
          cost = getEdgeWeight(e, graph.getEdgeAttributes(e)) + distances[v];
          if (cutoff && cost > cutoff)
            continue;
          if (u in distances && cost < distances[u]) {
            throw Error(
              "graphology-shortest-path/dijkstra: contradictory paths found. Do some of your edges have a negative weight?"
            );
          } else if (!(u in seen) || cost < seen[u]) {
            seen[u] = cost;
            fringe.push([cost, count++, u]);
            if (paths)
              paths[u] = paths[v].concat(u);
          }
        }
      }
      return distances;
    }
    function singleSourceDijkstra(graph, source, getEdgeWeight) {
      var paths = {};
      abstractDijkstraMultisource(graph, [source], getEdgeWeight, 0, null, paths);
      return paths;
    }
    function bidirectionalDijkstra(graph, source, target, getEdgeWeight) {
      return abstractBidirectionalDijkstra(graph, source, target, getEdgeWeight)[1];
    }
    function brandes(graph, source, getEdgeWeight) {
      source = "" + source;
      getEdgeWeight = createEdgeWeightGetter(
        getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE
      ).fromMinimalEntry;
      var S = [], P = {}, sigma = {};
      var nodes = graph.nodes(), edges, item, pred, dist, cost, v, w, e, i, l;
      for (i = 0, l = nodes.length; i < l; i++) {
        v = nodes[i];
        P[v] = [];
        sigma[v] = 0;
      }
      var D = {};
      sigma[source] = 1;
      var seen = {};
      seen[source] = 0;
      var count = 0;
      var Q = new Heap(BRANDES_DIJKSTRA_HEAP_COMPARATOR);
      Q.push([0, count++, source, source]);
      while (Q.size) {
        item = Q.pop();
        dist = item[0];
        pred = item[2];
        v = item[3];
        if (v in D)
          continue;
        sigma[v] += sigma[pred];
        S.push(v);
        D[v] = dist;
        edges = graph.outboundEdges(v);
        for (i = 0, l = edges.length; i < l; i++) {
          e = edges[i];
          w = graph.opposite(v, e);
          cost = dist + getEdgeWeight(e, graph.getEdgeAttributes(e));
          if (!(w in D) && (!(w in seen) || cost < seen[w])) {
            seen[w] = cost;
            Q.push([cost, count++, v, w]);
            sigma[w] = 0;
            P[w] = [v];
          } else if (cost === seen[w]) {
            sigma[w] += sigma[v];
            P[w].push(v);
          }
        }
      }
      return [S, P, sigma];
    }
    exports.bidirectional = bidirectionalDijkstra;
    exports.singleSource = singleSourceDijkstra;
    exports.brandes = brandes;
  }
});

// node_modules/graphology-shortest-path/index.js
var require_graphology_shortest_path = __commonJS({
  "node_modules/graphology-shortest-path/index.js"(exports) {
    var unweighted = require_unweighted();
    var utils = require_utils();
    exports.unweighted = unweighted;
    exports.dijkstra = require_dijkstra();
    exports.bidirectional = unweighted.bidirectional;
    exports.singleSource = unweighted.singleSource;
    exports.singleSourceLength = unweighted.singleSourceLength;
    exports.undirectedSingleSourceLength = unweighted.undirectedSingleSourceLength;
    exports.brandes = unweighted.brandes;
    exports.edgePathFromNodePath = utils.edgePathFromNodePath;
  }
});
export default require_graphology_shortest_path();
//# sourceMappingURL=graphology-shortest-path.js.map
