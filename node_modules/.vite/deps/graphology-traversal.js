import {
  require_is_graph,
  require_iterables
} from "./chunk-3F5NPONY.js";
import {
  require_iterator
} from "./chunk-KA5TYL5E.js";
import {
  __commonJS
} from "./chunk-5WWUZCGV.js";

// node_modules/mnemonist/fixed-deque.js
var require_fixed_deque = __commonJS({
  "node_modules/mnemonist/fixed-deque.js"(exports, module) {
    var iterables = require_iterables();
    var Iterator = require_iterator();
    function FixedDeque(ArrayClass, capacity) {
      if (arguments.length < 2)
        throw new Error("mnemonist/fixed-deque: expecting an Array class and a capacity.");
      if (typeof capacity !== "number" || capacity <= 0)
        throw new Error("mnemonist/fixed-deque: `capacity` should be a positive number.");
      this.ArrayClass = ArrayClass;
      this.capacity = capacity;
      this.items = new ArrayClass(this.capacity);
      this.clear();
    }
    FixedDeque.prototype.clear = function() {
      this.start = 0;
      this.size = 0;
    };
    FixedDeque.prototype.push = function(item) {
      if (this.size === this.capacity)
        throw new Error("mnemonist/fixed-deque.push: deque capacity (" + this.capacity + ") exceeded!");
      var index = (this.start + this.size) % this.capacity;
      this.items[index] = item;
      return ++this.size;
    };
    FixedDeque.prototype.unshift = function(item) {
      if (this.size === this.capacity)
        throw new Error("mnemonist/fixed-deque.unshift: deque capacity (" + this.capacity + ") exceeded!");
      var index = this.start - 1;
      if (this.start === 0)
        index = this.capacity - 1;
      this.items[index] = item;
      this.start = index;
      return ++this.size;
    };
    FixedDeque.prototype.pop = function() {
      if (this.size === 0)
        return;
      const index = (this.start + this.size - 1) % this.capacity;
      this.size--;
      return this.items[index];
    };
    FixedDeque.prototype.shift = function() {
      if (this.size === 0)
        return;
      var index = this.start;
      this.size--;
      this.start++;
      if (this.start === this.capacity)
        this.start = 0;
      return this.items[index];
    };
    FixedDeque.prototype.peekFirst = function() {
      if (this.size === 0)
        return;
      return this.items[this.start];
    };
    FixedDeque.prototype.peekLast = function() {
      if (this.size === 0)
        return;
      var index = this.start + this.size - 1;
      if (index > this.capacity)
        index -= this.capacity;
      return this.items[index];
    };
    FixedDeque.prototype.get = function(index) {
      if (this.size === 0)
        return;
      index = this.start + index;
      if (index > this.capacity)
        index -= this.capacity;
      return this.items[index];
    };
    FixedDeque.prototype.forEach = function(callback, scope) {
      scope = arguments.length > 1 ? scope : this;
      var c = this.capacity, l = this.size, i = this.start, j = 0;
      while (j < l) {
        callback.call(scope, this.items[i], j, this);
        i++;
        j++;
        if (i === c)
          i = 0;
      }
    };
    FixedDeque.prototype.toArray = function() {
      var offset = this.start + this.size;
      if (offset < this.capacity)
        return this.items.slice(this.start, offset);
      var array = new this.ArrayClass(this.size), c = this.capacity, l = this.size, i = this.start, j = 0;
      while (j < l) {
        array[j] = this.items[i];
        i++;
        j++;
        if (i === c)
          i = 0;
      }
      return array;
    };
    FixedDeque.prototype.values = function() {
      var items = this.items, c = this.capacity, l = this.size, i = this.start, j = 0;
      return new Iterator(function() {
        if (j >= l)
          return {
            done: true
          };
        var value = items[i];
        i++;
        j++;
        if (i === c)
          i = 0;
        return {
          value,
          done: false
        };
      });
    };
    FixedDeque.prototype.entries = function() {
      var items = this.items, c = this.capacity, l = this.size, i = this.start, j = 0;
      return new Iterator(function() {
        if (j >= l)
          return {
            done: true
          };
        var value = items[i];
        i++;
        if (i === c)
          i = 0;
        return {
          value: [j++, value],
          done: false
        };
      });
    };
    if (typeof Symbol !== "undefined")
      FixedDeque.prototype[Symbol.iterator] = FixedDeque.prototype.values;
    FixedDeque.prototype.inspect = function() {
      var array = this.toArray();
      array.type = this.ArrayClass.name;
      array.capacity = this.capacity;
      Object.defineProperty(array, "constructor", {
        value: FixedDeque,
        enumerable: false
      });
      return array;
    };
    if (typeof Symbol !== "undefined")
      FixedDeque.prototype[Symbol.for("nodejs.util.inspect.custom")] = FixedDeque.prototype.inspect;
    FixedDeque.from = function(iterable, ArrayClass, capacity) {
      if (arguments.length < 3) {
        capacity = iterables.guessLength(iterable);
        if (typeof capacity !== "number")
          throw new Error("mnemonist/fixed-deque.from: could not guess iterable length. Please provide desired capacity as last argument.");
      }
      var deque = new FixedDeque(ArrayClass, capacity);
      if (iterables.isArrayLike(iterable)) {
        var i, l;
        for (i = 0, l = iterable.length; i < l; i++)
          deque.items[i] = iterable[i];
        deque.size = l;
        return deque;
      }
      iterables.forEach(iterable, function(value) {
        deque.push(value);
      });
      return deque;
    };
    module.exports = FixedDeque;
  }
});

// node_modules/graphology-indices/bfs-queue.js
var require_bfs_queue = __commonJS({
  "node_modules/graphology-indices/bfs-queue.js"(exports, module) {
    var FixedDeque = require_fixed_deque();
    function BFSQueue(graph) {
      this.graph = graph;
      this.queue = new FixedDeque(Array, graph.order);
      this.seen = /* @__PURE__ */ new Set();
      this.size = 0;
    }
    BFSQueue.prototype.hasAlreadySeenEverything = function() {
      return this.seen.size === this.graph.order;
    };
    BFSQueue.prototype.countUnseenNodes = function() {
      return this.graph.order - this.seen.size;
    };
    BFSQueue.prototype.forEachNodeYetUnseen = function(callback) {
      var seen = this.seen;
      var graph = this.graph;
      graph.someNode(function(node, attr) {
        if (seen.size === graph.order)
          return true;
        if (seen.has(node))
          return false;
        var shouldBreak = callback(node, attr);
        if (shouldBreak)
          return true;
        return false;
      });
    };
    BFSQueue.prototype.has = function(node) {
      return this.seen.has(node);
    };
    BFSQueue.prototype.push = function(node) {
      var seenSizeBefore = this.seen.size;
      this.seen.add(node);
      if (seenSizeBefore === this.seen.size)
        return false;
      this.queue.push(node);
      this.size++;
      return true;
    };
    BFSQueue.prototype.pushWith = function(node, item) {
      var seenSizeBefore = this.seen.size;
      this.seen.add(node);
      if (seenSizeBefore === this.seen.size)
        return false;
      this.queue.push(item);
      this.size++;
      return true;
    };
    BFSQueue.prototype.shift = function() {
      var item = this.queue.shift();
      this.size = this.queue.size;
      return item;
    };
    module.exports = BFSQueue;
  }
});

// node_modules/graphology-traversal/utils.js
var require_utils = __commonJS({
  "node_modules/graphology-traversal/utils.js"(exports) {
    function TraversalRecord(node, attr, depth) {
      this.node = node;
      this.attributes = attr;
      this.depth = depth;
    }
    function capitalize(string) {
      return string[0].toUpperCase() + string.slice(1);
    }
    exports.TraversalRecord = TraversalRecord;
    exports.capitalize = capitalize;
  }
});

// node_modules/graphology-traversal/bfs.js
var require_bfs = __commonJS({
  "node_modules/graphology-traversal/bfs.js"(exports) {
    var isGraph = require_is_graph();
    var BFSQueue = require_bfs_queue();
    var utils = require_utils();
    var TraversalRecord = utils.TraversalRecord;
    var capitalize = utils.capitalize;
    function abstractBfs(graph, startingNode, callback, options) {
      options = options || {};
      if (!isGraph(graph))
        throw new Error(
          "graphology-traversal/bfs: expecting a graphology instance."
        );
      if (typeof callback !== "function")
        throw new Error(
          "graphology-traversal/bfs: given callback is not a function."
        );
      if (graph.order === 0)
        return;
      var queue = new BFSQueue(graph);
      var forEachNeighbor = graph["forEach" + capitalize(options.mode || "outbound") + "Neighbor"].bind(
        graph
      );
      var forEachNode;
      if (startingNode === null) {
        forEachNode = queue.forEachNodeYetUnseen.bind(queue);
      } else {
        forEachNode = function(fn) {
          startingNode = "" + startingNode;
          fn(startingNode, graph.getNodeAttributes(startingNode));
        };
      }
      var record, stop;
      function visit(neighbor, attr) {
        queue.pushWith(
          neighbor,
          new TraversalRecord(neighbor, attr, record.depth + 1)
        );
      }
      forEachNode(function(node, attr) {
        queue.pushWith(node, new TraversalRecord(node, attr, 0));
        while (queue.size !== 0) {
          record = queue.shift();
          stop = callback(record.node, record.attributes, record.depth);
          if (stop === true)
            continue;
          forEachNeighbor(record.node, visit);
        }
      });
    }
    exports.bfs = function(graph, callback, options) {
      return abstractBfs(graph, null, callback, options);
    };
    exports.bfsFromNode = abstractBfs;
  }
});

// node_modules/graphology-indices/dfs-stack.js
var require_dfs_stack = __commonJS({
  "node_modules/graphology-indices/dfs-stack.js"(exports, module) {
    function DFSStack(graph) {
      this.graph = graph;
      this.stack = new Array(graph.order);
      this.seen = /* @__PURE__ */ new Set();
      this.size = 0;
    }
    DFSStack.prototype.hasAlreadySeenEverything = function() {
      return this.seen.size === this.graph.order;
    };
    DFSStack.prototype.countUnseenNodes = function() {
      return this.graph.order - this.seen.size;
    };
    DFSStack.prototype.forEachNodeYetUnseen = function(callback) {
      var seen = this.seen;
      var graph = this.graph;
      graph.someNode(function(node, attr) {
        if (seen.size === graph.order)
          return true;
        if (seen.has(node))
          return false;
        var shouldBreak = callback(node, attr);
        if (shouldBreak)
          return true;
        return false;
      });
    };
    DFSStack.prototype.has = function(node) {
      return this.seen.has(node);
    };
    DFSStack.prototype.push = function(node) {
      var seenSizeBefore = this.seen.size;
      this.seen.add(node);
      if (seenSizeBefore === this.seen.size)
        return false;
      this.stack[this.size++] = node;
      return true;
    };
    DFSStack.prototype.pushWith = function(node, item) {
      var seenSizeBefore = this.seen.size;
      this.seen.add(node);
      if (seenSizeBefore === this.seen.size)
        return false;
      this.stack[this.size++] = item;
      return true;
    };
    DFSStack.prototype.pop = function() {
      if (this.size === 0)
        return;
      return this.stack[--this.size];
    };
    module.exports = DFSStack;
  }
});

// node_modules/graphology-traversal/dfs.js
var require_dfs = __commonJS({
  "node_modules/graphology-traversal/dfs.js"(exports) {
    var isGraph = require_is_graph();
    var DFSStack = require_dfs_stack();
    var utils = require_utils();
    var TraversalRecord = utils.TraversalRecord;
    var capitalize = utils.capitalize;
    function abstractDfs(graph, startingNode, callback, options) {
      options = options || {};
      if (!isGraph(graph))
        throw new Error(
          "graphology-traversal/dfs: expecting a graphology instance."
        );
      if (typeof callback !== "function")
        throw new Error(
          "graphology-traversal/dfs: given callback is not a function."
        );
      if (graph.order === 0)
        return;
      var stack = new DFSStack(graph);
      var forEachNeighbor = graph["forEach" + capitalize(options.mode || "outbound") + "Neighbor"].bind(
        graph
      );
      var forEachNode;
      if (startingNode === null) {
        forEachNode = stack.forEachNodeYetUnseen.bind(stack);
      } else {
        forEachNode = function(fn) {
          startingNode = "" + startingNode;
          fn(startingNode, graph.getNodeAttributes(startingNode));
        };
      }
      var record, stop;
      function visit(neighbor, attr) {
        stack.pushWith(
          neighbor,
          new TraversalRecord(neighbor, attr, record.depth + 1)
        );
      }
      forEachNode(function(node, attr) {
        stack.pushWith(node, new TraversalRecord(node, attr, 0));
        while (stack.size !== 0) {
          record = stack.pop();
          stop = callback(record.node, record.attributes, record.depth);
          if (stop === true)
            continue;
          forEachNeighbor(record.node, visit);
        }
      });
    }
    exports.dfs = function(graph, callback, options) {
      return abstractDfs(graph, null, callback, options);
    };
    exports.dfsFromNode = abstractDfs;
  }
});

// node_modules/graphology-traversal/index.js
var require_graphology_traversal = __commonJS({
  "node_modules/graphology-traversal/index.js"(exports) {
    var bfsModule = require_bfs();
    var dfsModule = require_dfs();
    exports.bfs = bfsModule.bfs;
    exports.bfsFromNode = bfsModule.bfsFromNode;
    exports.dfs = dfsModule.dfs;
    exports.dfsFromNode = dfsModule.dfsFromNode;
  }
});
export default require_graphology_traversal();
//# sourceMappingURL=graphology-traversal.js.map
